
# ###############################################################################
# Copyright : Rahul Singh
# URL       : https://github.com/codecliff/PhotoGlimmer
# License   : LGPL
# email     : codecliff@users.noreply.github.com
# Disclaimer: No warranties, stated or implied.
#  Description:
#  Main image display area
#  With enhancements rectangles drawing, resizing, moving, hiding,
#  deleting and  bounding coordinates retreival; pixmap swapping. 
#  Ack- Unlike most of the other code in Photoglimmer, the code in this
#  file is largely generated by AI  
# ###############################################################################
import sys
from enum import Enum
from PySide2 import QtCore, QtGui, QtWidgets
# --- Interaction Modes Enum ---


class  InteractionMode(Enum):
    NONE = 0
    DRAWING = 1
    MOVING = 2
    RESIZING = 3
# --- Resize Handle Positions Enum ---


class  HandlePosition(Enum):
    NONE = 0
    TOP_LEFT = 1
    TOP = 2
    TOP_RIGHT = 3
    LEFT = 4
    RIGHT = 5
    BOTTOM_LEFT = 6
    BOTTOM = 7
    BOTTOM_RIGHT = 8
    BODY = 9 # Represents the main body for moving


class  ImageLabel(QtWidgets.QLabel):
    HANDLE_SIZE = 8
    HIT_MARGIN = 5
    rectangles_changed = QtCore.Signal()
    primary_image_changed = QtCore.Signal()
    secondary_image_changed = QtCore.Signal()


    def  __init__(self, parent=None):
        super().__init__(parent)
        self.pixmap1 = None 
        self.pixmap2 = None 
        self.image_rect = QtCore.QRect() 
        self.rectangles = []
        self.current_rect = QtCore.QRect()
        self.start_point = QtCore.QPoint()
        self.drag_offset = QtCore.QPoint()
        self.selected_rect_index = -1
        self.interaction_mode = InteractionMode.NONE
        self.active_handle = HandlePosition.NONE
        self._show_rectangles = True
        self._right_mouse_pressed = False 
        self.setMinimumSize(1, 1)
        self.setMouseTracking(True)
        self.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        self.setFocusPolicy(QtCore.Qt.StrongFocus)


    def  _update_display(self):
        if self._right_mouse_pressed and self.pixmap2:
            self.setPixmap(self.pixmap2)
        elif self.pixmap1:
            self.setPixmap(self.pixmap1)
        else:
            self.setPixmap(QtGui.QPixmap()) 
            self.setFixedSize(1,1) 
        self.update() 


    def  set_image(self, file_path):
        pixmap = QtGui.QPixmap(file_path)
        if pixmap.isNull():
            print(f"Error: Could not load primary image from {file_path}")
            self.pixmap1 = None
            self.pixmap2 = None
            self.image_rect = QtCore.QRect()
            self.rectangles = []
            self.selected_rect_index = -1
            self.interaction_mode = InteractionMode.NONE
            self.current_rect = QtCore.QRect()
            self._right_mouse_pressed = False
            self._update_display() 
            self.rectangles_changed.emit()
            self.primary_image_changed.emit()
            self.secondary_image_changed.emit() 
            return False
        self.pixmap1 = pixmap
        self.pixmap2 = None 
        self.image_rect = self.pixmap1.rect()
        self.rectangles = [] 
        self.selected_rect_index = -1
        self.interaction_mode = InteractionMode.NONE
        self.current_rect = QtCore.QRect()
        self._right_mouse_pressed = False
        self.setFixedSize(self.pixmap1.size())
        self._update_display() 
        self.rectangles_changed.emit()
        self.primary_image_changed.emit()
        self.secondary_image_changed.emit()
        self.set_rectangles_visible(True) 
        return True


    def  change_image(self, file_path):
        if not self.pixmap1:
            print("Error: Cannot change image, load a primary image first using set_image().")
            return False
        new_pixmap = QtGui.QPixmap(file_path)
        if new_pixmap.isNull():
            print(f"Error: Could not load image from {file_path} to change.")
            return False
        if new_pixmap.size() != self.pixmap1.size():
            print(f"Error: New image dimensions ({new_pixmap.width()}x{new_pixmap.height()}) "
                  f"do not match current primary image dimensions ({self.image_rect.width()}x{self.image_rect.height()}). "
                  "Rectangles not preserved.")
            return False
        self.pixmap1 = new_pixmap
        self.pixmap2 = None 
        self._right_mouse_pressed = False 
        self._update_display() 
        self.primary_image_changed.emit()
        self.secondary_image_changed.emit()
        return True


    def  set_secondary_image(self, file_path):
        if not self.pixmap1:
            print("Error: Cannot set secondary image, load a primary image first using set_image().")
            return False
        new_pixmap = QtGui.QPixmap(file_path)
        if new_pixmap.isNull():
            print(f"Error: Could not load secondary image from {file_path}.")
            self.pixmap2 = None 
            self.secondary_image_changed.emit()
            return False
        if new_pixmap.size() != self.pixmap1.size():
            print(f"Error: Secondary image dimensions ({new_pixmap.width()}x{new_pixmap.height()}) "
                  f"do not match primary image dimensions ({self.image_rect.width()}x{self.image_rect.height()}).")
            self.pixmap2 = None 
            self.secondary_image_changed.emit()
            return False
        self.pixmap2 = new_pixmap
        self._right_mouse_pressed = False 
        self._update_display() 
        self.secondary_image_changed.emit()
        return True


    def  has_primary_image(self) -> bool:
        return self.pixmap1 is not None


    def  has_secondary_image(self) -> bool:
        return self.pixmap2 is not None


    def  delete_all_rectangles(self):
        if not self.rectangles:
            return
        self.rectangles = []
        self.selected_rect_index = -1
        self.interaction_mode = InteractionMode.NONE
        self.current_rect = QtCore.QRect()
        self.rectangles_changed.emit()
        self.update()


    def  get_all_rectangles(self, output_format_xywh=True):
        if not self.pixmap1 :
            return []
        if not  self.rectangles:
            if output_format_xywh : return [self.image_rect.getRect()]
            else: return [ self.image_rect.getCoords() ]
        clipped_rects = [rect.intersected(self.image_rect) for rect in self.rectangles]
        valid_rects = [r for r in clipped_rects if not r.isEmpty() and r.isValid()]
        if not valid_rects: valid_rects.append(self.image_rect) 
        if output_format_xywh: return [r.getRect() for r in valid_rects]
        else: return [r.getCoords() for r in valid_rects]


    def  set_rectangles_visible(self, visible: bool):
        if self._show_rectangles != visible:
            self._show_rectangles = visible
            if not visible:
                self.selected_rect_index = -1
                self.interaction_mode = InteractionMode.NONE
                self.current_rect = QtCore.QRect()
                self.setCursor(QtCore.Qt.ArrowCursor)
            self.update()


    def  are_rectangles_visible(self) -> bool:
        return self._show_rectangles


    def  _get_handle_rects(self, rect):
        handles = {}
        hs_marg = (self.HANDLE_SIZE // 2) + self.HIT_MARGIN
        handles[HandlePosition.TOP_LEFT]     = QtCore.QRect(rect.topLeft()     - QtCore.QPoint(hs_marg, hs_marg), QtCore.QSize(2 * hs_marg, 2 * hs_marg))
        handles[HandlePosition.TOP_RIGHT]    = QtCore.QRect(rect.topRight()    - QtCore.QPoint(-hs_marg, hs_marg), QtCore.QSize(2 * hs_marg, 2 * hs_marg))
        handles[HandlePosition.BOTTOM_LEFT]  = QtCore.QRect(rect.bottomLeft()  - QtCore.QPoint(hs_marg, -hs_marg), QtCore.QSize(2 * hs_marg, 2 * hs_marg))
        handles[HandlePosition.BOTTOM_RIGHT] = QtCore.QRect(rect.bottomRight() - QtCore.QPoint(-hs_marg, -hs_marg), QtCore.QSize(2 * hs_marg, 2 * hs_marg))
        mid_x = rect.left() + rect.width() // 2
        mid_y = rect.top() + rect.height() // 2
        handles[HandlePosition.TOP]    = QtCore.QRect(mid_x - hs_marg, rect.top()    - hs_marg, 2 * hs_marg, 2 * hs_marg)
        handles[HandlePosition.BOTTOM] = QtCore.QRect(mid_x - hs_marg, rect.bottom() - hs_marg, 2 * hs_marg, 2 * hs_marg)
        handles[HandlePosition.LEFT]   = QtCore.QRect(rect.left()   - hs_marg, mid_y - hs_marg, 2 * hs_marg, 2 * hs_marg)
        handles[HandlePosition.RIGHT]  = QtCore.QRect(rect.right()  - hs_marg, mid_y - hs_marg, 2 * hs_marg, 2 * hs_marg)
        return handles


    def  _get_handle_at_pos(self, pos):
        if self.selected_rect_index != -1 and self._show_rectangles:
            selected_rect = self.rectangles[self.selected_rect_index]
            if selected_rect.isValid():
                handle_rects = self._get_handle_rects(selected_rect)
                for handle, h_rect in handle_rects.items():
                    if h_rect.contains(pos):
                        return handle
        return HandlePosition.NONE


    def  mousePressEvent(self, event: QtGui.QMouseEvent):
        if not self.pixmap1: 
            super().mousePressEvent(event)
            return
        if event.button() == QtCore.Qt.RightButton:
            if self.pixmap2: 
                self._right_mouse_pressed = True
                self._update_display() 
                event.accept() 
            else:
                event.accept() 
            return 
        if event.button() == QtCore.Qt.LeftButton and self._show_rectangles:
            self.start_point = event.pos()
            clicked_rect_index = -1
            clicked_handle = HandlePosition.NONE
            if self.selected_rect_index != -1:
                 clicked_handle = self._get_handle_at_pos(self.start_point)
                 if clicked_handle != HandlePosition.NONE:
                     self.interaction_mode = InteractionMode.RESIZING
                     self.active_handle = clicked_handle
                     self.current_rect = QtCore.QRect(self.rectangles[self.selected_rect_index])
                     self.update()
                     event.accept()
                     return
            for i in range(len(self.rectangles) - 1, -1, -1):
                if self.rectangles[i].adjusted(1, 1, -1, -1).contains(self.start_point):
                    clicked_rect_index = i
                    break
            if clicked_rect_index != -1:
                if self.selected_rect_index != clicked_rect_index:
                    self.selected_rect_index = clicked_rect_index
                self.interaction_mode = InteractionMode.MOVING
                self.active_handle = HandlePosition.BODY
                self.drag_offset = self.start_point - self.rectangles[self.selected_rect_index].topLeft()
                self.current_rect = QtCore.QRect(self.rectangles[self.selected_rect_index])
            else:
                if self.selected_rect_index != -1:
                     self.selected_rect_index = -1
                     self.interaction_mode = InteractionMode.NONE
                self.interaction_mode = InteractionMode.DRAWING
                self.selected_rect_index = -1
                self.current_rect = QtCore.QRect(self.start_point, self.start_point).normalized()
            self.update()
            event.accept()
        elif event.button() == QtCore.Qt.LeftButton and not self._show_rectangles:
             print("Rectangles hidden, ignoring left click.")
             event.accept()
        else:
             super().mousePressEvent(event) 


    def  mouseMoveEvent(self, event: QtGui.QMouseEvent):
        if not self.pixmap1:
            super().mouseMoveEvent(event)
            return
        pos = event.pos()
        if event.buttons() & QtCore.Qt.LeftButton and self._show_rectangles:
            if self.interaction_mode == InteractionMode.DRAWING:
                clamped_pos = self._clamp_pos(pos)
                self.current_rect = QtCore.QRect(self.start_point, clamped_pos).normalized()
                self.update()
            elif self.interaction_mode == InteractionMode.MOVING:
                if self.selected_rect_index != -1:
                    new_top_left = pos - self.drag_offset
                    preview_rect = QtCore.QRect(self.rectangles[self.selected_rect_index])
                    preview_rect.moveTo(new_top_left)
                    self.current_rect = preview_rect
                    self.update()
            elif self.interaction_mode == InteractionMode.RESIZING:
                 if self.selected_rect_index != -1:
                    temp_rect = QtCore.QRect(self.rectangles[self.selected_rect_index])
                    clamped_pos = self._clamp_pos(pos)
                    if self.active_handle == HandlePosition.TOP_LEFT: temp_rect.setTopLeft(clamped_pos)
                    elif self.active_handle == HandlePosition.TOP: temp_rect.setTop(clamped_pos.y())
                    elif self.active_handle == HandlePosition.TOP_RIGHT: temp_rect.setTopRight(clamped_pos)
                    elif self.active_handle == HandlePosition.LEFT: temp_rect.setLeft(clamped_pos.x())
                    elif self.active_handle == HandlePosition.RIGHT: temp_rect.setRight(clamped_pos.x())
                    elif self.active_handle == HandlePosition.BOTTOM_LEFT: temp_rect.setBottomLeft(clamped_pos)
                    elif self.active_handle == HandlePosition.BOTTOM: temp_rect.setBottom(clamped_pos.y())
                    elif self.active_handle == HandlePosition.BOTTOM_RIGHT: temp_rect.setBottomRight(clamped_pos)
                    self.current_rect = temp_rect
                    self.update()
            event.accept() 
            return 
        if self._show_rectangles and self.interaction_mode == InteractionMode.NONE:
            hover_handle = HandlePosition.NONE
            hover_rect_body = False
            if self.selected_rect_index != -1:
                hover_handle = self._get_handle_at_pos(pos)
            if hover_handle == HandlePosition.NONE:
                 current_hover_target = -1
                 for i in range(len(self.rectangles) - 1, -1, -1):
                     if self.rectangles[i].adjusted(-2, -2, 2, 2).contains(pos):
                          current_hover_target = i
                          break
                 if current_hover_target != -1:
                      if self.selected_rect_index == -1 or self.selected_rect_index == current_hover_target:
                           hover_rect_body = True
            cursor = QtCore.Qt.CrossCursor
            if hover_handle in (HandlePosition.TOP_LEFT, HandlePosition.BOTTOM_RIGHT): cursor = QtCore.Qt.SizeFDiagCursor
            elif hover_handle in (HandlePosition.TOP_RIGHT, HandlePosition.BOTTOM_LEFT): cursor = QtCore.Qt.SizeBDiagCursor
            elif hover_handle in (HandlePosition.TOP, HandlePosition.BOTTOM): cursor = QtCore.Qt.SizeVerCursor
            elif hover_handle in (HandlePosition.LEFT, HandlePosition.RIGHT): cursor = QtCore.Qt.SizeHorCursor
            elif hover_rect_body: cursor = QtCore.Qt.SizeAllCursor
            self.setCursor(QtGui.QCursor(cursor))
        elif not self._show_rectangles:
             self.setCursor(QtCore.Qt.ArrowCursor) 
        super().mouseMoveEvent(event)


    def  mouseReleaseEvent(self, event: QtGui.QMouseEvent):
        if not self.pixmap1:
            super().mouseReleaseEvent(event)
            return
        if event.button() == QtCore.Qt.RightButton:
            if self._right_mouse_pressed: 
                self._right_mouse_pressed = False
                self._update_display() 
                event.accept()
            else:
                 event.accept() 
            return 
        if event.button() == QtCore.Qt.LeftButton and self.interaction_mode != InteractionMode.NONE:
            changed = False
            if self.interaction_mode == InteractionMode.DRAWING:
                final_rect = self._clamp_rect(self.current_rect.normalized())  
                if final_rect.width() > 2 and final_rect.height() > 2 and not final_rect.isEmpty():
                    self.rectangles.append(final_rect)
                    self.selected_rect_index = len(self.rectangles) - 1
                    changed = True
                else:
                    self.selected_rect_index = -1
            elif self.interaction_mode == InteractionMode.MOVING:
                if self.selected_rect_index != -1:
                    final_rect = self._clamp_rect(self.current_rect)
                    if not final_rect.isEmpty() and final_rect.isValid():
                         if self.rectangles[self.selected_rect_index] != final_rect:
                             self.rectangles[self.selected_rect_index] = final_rect
                             changed = True
                    self.current_rect = QtCore.QRect()
            elif self.interaction_mode == InteractionMode.RESIZING:
                if self.selected_rect_index != -1:
                    final_rect = self._clamp_rect(self.current_rect.normalized())
                    if final_rect.width() > 0 and final_rect.height() > 0 and not final_rect.isEmpty():
                         if self.rectangles[self.selected_rect_index] != final_rect:
                             self.rectangles[self.selected_rect_index] = final_rect
                             changed = True
                    self.current_rect = QtCore.QRect()
            self.interaction_mode = InteractionMode.NONE
            self.active_handle = HandlePosition.NONE
            self.current_rect = QtCore.QRect()
            if not self._show_rectangles: self.setCursor(QtCore.Qt.ArrowCursor)
            if changed: self.rectangles_changed.emit()
            self.update()
            event.accept()
        else:
            super().mouseReleaseEvent(event) 


    def  keyPressEvent(self, event: QtGui.QKeyEvent):
        if event.key() == QtCore.Qt.Key_H:
            is_visible = self.are_rectangles_visible()
            self.set_rectangles_visible(not is_visible)
            self.setFocus()
        elif event.key() == QtCore.Qt.Key_Delete:
            if not self._show_rectangles: 
                super().keyPressEvent(event)
                return
            if self.selected_rect_index != -1:
                del self.rectangles[self.selected_rect_index]
                self.selected_rect_index = -1
                self.interaction_mode = InteractionMode.NONE
                self.current_rect = QtCore.QRect()
                self.rectangles_changed.emit()
                self.update()
                event.accept()
            else:
                super().keyPressEvent(event) 
        else:
            super().keyPressEvent(event)


    def  _clamp_pos(self, pos):
        if self.image_rect.isNull(): return pos
        x = max(self.image_rect.left(), min(pos.x(), self.image_rect.right()))
        y = max(self.image_rect.top(), min(pos.y(), self.image_rect.bottom()))
        return QtCore.QPoint(x, y)


    def  _clamp_rect(self, rect):
        if self.image_rect.isNull(): return QtCore.QRect()
        clamped = rect.intersected(self.image_rect)
        return clamped if clamped.isValid() else QtCore.QRect()


    def  paintEvent(self, event: QtGui.QPaintEvent):
        super().paintEvent(event)
        if self.pixmap1 and self._show_rectangles:
            painter = QtGui.QPainter(self)
            painter.setRenderHint(QtGui.QPainter.Antialiasing, False)
            CURVE_COLOR = QtGui.QColor(171, 205, 239)
            pen_default = QtGui.QPen(CURVE_COLOR); pen_default.setWidth(1)
            pen_selected = QtGui.QPen(QtCore.Qt.red); pen_selected.setWidth(2)
            pen_preview = QtGui.QPen(QtCore.Qt.white); pen_preview.setWidth(1)
            pen_preview.setStyle(QtCore.Qt.DashLine)
            painter.setPen(pen_default)
            for i, rect in enumerate(self.rectangles):
                 if i != self.selected_rect_index and rect.isValid():
                    painter.drawRect(rect)
            if self.interaction_mode != InteractionMode.NONE and not self.current_rect.isNull():
                 preview_draw_rect = self.current_rect.normalized()
                 if preview_draw_rect.isValid():
                     painter.setPen(pen_preview)
                     painter.drawRect(preview_draw_rect)
            if self.selected_rect_index != -1:
                rect_to_adorn = None
                draw_solid_selected = False
                if self.interaction_mode == InteractionMode.MOVING or self.interaction_mode == InteractionMode.RESIZING:
                    rect_to_adorn = self.current_rect
                else:
                    rect_to_adorn = self.rectangles[self.selected_rect_index]
                    draw_solid_selected = True
                if rect_to_adorn and rect_to_adorn.isValid():
                    if draw_solid_selected:
                        painter.setPen(pen_selected)
                        painter.drawRect(rect_to_adorn.normalized())
                    painter.setPen(QtCore.Qt.black); painter.setBrush(QtCore.Qt.white)
                    hs = self.HANDLE_SIZE // 2
                    r_norm = rect_to_adorn.normalized()
                    handle_centers = { 
                        HandlePosition.TOP_LEFT: r_norm.topLeft(), HandlePosition.TOP_RIGHT: r_norm.topRight(),
                        HandlePosition.BOTTOM_LEFT: r_norm.bottomLeft(), HandlePosition.BOTTOM_RIGHT: r_norm.bottomRight(),
                        HandlePosition.TOP: QtCore.QPoint(r_norm.center().x(), r_norm.top()),
                        HandlePosition.BOTTOM: QtCore.QPoint(r_norm.center().x(), r_norm.bottom()),
                        HandlePosition.LEFT: QtCore.QPoint(r_norm.left(), r_norm.center().y()),
                        HandlePosition.RIGHT: QtCore.QPoint(r_norm.right(), r_norm.center().y()),
                    }
                    for center_pos in handle_centers.values():
                        handle_draw_rect = QtCore.QRect(center_pos.x() - hs, center_pos.y() - hs, self.HANDLE_SIZE, self.HANDLE_SIZE)
                        painter.drawRect(handle_draw_rect)
            painter.end()
if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    window = QtWidgets.QMainWindow()
    window.setWindowTitle("Enhanced ImageLabel Example - Image Swap & Toggle")
    window.setGeometry(100, 100, 900, 700)
    central_widget = QtWidgets.QWidget()
    window.setCentralWidget(central_widget)
    layout = QtWidgets.QVBoxLayout(central_widget)
    image_label = ImageLabel()
    controls_layout_1 = QtWidgets.QHBoxLayout()
    btn_load_primary = QtWidgets.QPushButton("Load Primary (Clear Rects)")
    btn_change_primary = QtWidgets.QPushButton("Change Primary (Keep Rects)")
    btn_load_secondary = QtWidgets.QPushButton("Load Secondary (for Toggle)")
    controls_layout_1.addWidget(btn_load_primary)
    controls_layout_1.addWidget(btn_change_primary)
    controls_layout_1.addWidget(btn_load_secondary)
    layout.addLayout(controls_layout_1)
    controls_layout_2 = QtWidgets.QHBoxLayout()
    btn_clear = QtWidgets.QPushButton("Delete All Rects")
    btn_toggle_vis = QtWidgets.QPushButton("Toggle Rect Visibility")
    chk_coords = QtWidgets.QCheckBox("Get Coords (x1,y1,x2,y2)")
    btn_get_coords = QtWidgets.QPushButton("Get Coordinates")
    controls_layout_2.addWidget(btn_clear)
    controls_layout_2.addWidget(btn_toggle_vis)
    controls_layout_2.addWidget(chk_coords)
    controls_layout_2.addWidget(btn_get_coords)
    layout.addLayout(controls_layout_2)
    status_label = QtWidgets.QLabel("Status: No image loaded. Right-click to toggle secondary image (if loaded).")
    layout.addWidget(status_label)
    scroll_area = QtWidgets.QScrollArea()
    scroll_area.setWidgetResizable(True)
    scroll_area.setWidget(image_label)
    layout.addWidget(scroll_area)


    def  load_primary():
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(window, "Load Primary Image", "", "Image Files (*.png *.jpg *.bmp)")
        if file_path:
            if image_label.set_image(file_path):
                status_label.setText(f"Primary image loaded: {file_path.split('/')[-1]}. Rects cleared.")
            else:
                 status_label.setText("Failed to load primary image.")


    def  change_primary():
        if not image_label.has_primary_image():
             status_label.setText("Load a primary image first!")
             return
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(window, "Change Primary Image (Same Dimensions Only)", "", "Image Files (*.png *.jpg *.bmp)")
        if file_path:
            if image_label.change_image(file_path):
                 status_label.setText(f"Primary image changed to: {file_path.split('/')[-1]}. Rects preserved.")
            else:
                 status_label.setText("Failed to change primary image (check dimensions or file).")


    def  load_secondary():
        if not image_label.has_primary_image():
             status_label.setText("Load a primary image first!")
             return
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(window, "Load Secondary Image (Same Dimensions Only)", "", "Image Files (*.png *.jpg *.bmp)")
        if file_path:
            if image_label.set_secondary_image(file_path):
                 status_label.setText(f"Secondary image set: {file_path.split('/')[-1]}. Right-click to toggle.")
            else:
                 status_label.setText("Failed to set secondary image (check dimensions or file).")


    def  get_coords():
        use_xyxy = chk_coords.isChecked()
        rects = image_label.get_all_rectangles(output_format_xywh=(not use_xyxy))
        print("-" * 20)
        coord_type = "(x1, y1, x2, y2)" if use_xyxy else "(x, y, width, height)"
        print(f"Rectangles {coord_type}:")
        if rects:
            for i, r in enumerate(rects): print(f"  Rect {i}: {r}")
        else: print("  No rectangles found.")
        print("-" * 20)
        status_label.setText(f"Printed {len(rects)} rectangle coordinates to console.")


    def  toggle_visibility():
        is_visible = image_label.are_rectangles_visible()
        image_label.set_rectangles_visible(not is_visible)
        vis_text = "visible" if not is_visible else "hidden"
        status_label.setText(f"Rectangles set to {vis_text}.")
        image_label.setFocus()


    def  clear_rects_action():
        image_label.delete_all_rectangles()
        status_label.setText("All rectangles deleted.")
    btn_load_primary.clicked.connect(load_primary)
    btn_change_primary.clicked.connect(change_primary)
    btn_load_secondary.clicked.connect(load_secondary)
    btn_clear.clicked.connect(clear_rects_action)
    btn_get_coords.clicked.connect(get_coords)
    btn_toggle_vis.clicked.connect(toggle_visibility)


    def  update_status_on_rect_change():
        count = len(image_label.get_all_rectangles())
        has_secondary = image_label.has_secondary_image()
        current_status = status_label.text().split('.')[0] 
        toggle_info = " Right-click to toggle." if has_secondary else ""
        status_label.setText(f"{current_status}. Rect count: {count}.{toggle_info}")


    def  update_status_on_secondary_change():
         has_secondary = image_label.has_secondary_image()
         current_status = status_label.text().split('.')[0]
         toggle_info = " Right-click to toggle." if has_secondary else ""
         status_label.setText(f"{current_status}.{toggle_info}")
    image_label.rectangles_changed.connect(update_status_on_rect_change)
    image_label.secondary_image_changed.connect(update_status_on_secondary_change)
    window.show()
    sys.exit(app.exec_())